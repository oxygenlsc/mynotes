# node环境中搭建ts 学习环境

# 安装TypeScript

tsc index.ts 使用tsc全局命令 编译


默认情况下 TS会做出下面几种假设

1. 假设当前的执行环境是dom 
2. 如果代码中没有使用模块化语句（import export）,便会认为改代码是全局执行的
3. 编译目标代码是ES3
有2种方式更改以上假设

1. 使用tsc命令行的时候加上一些选项参数
2. 使用ts配置文件来更改变异选项

# ts配置文件添加

有2种办法，

1. 自己创建文件 tsconfig.json
2. 使用命令行 tsc --init 它会帮我们生成这个文件

使用了配置文件后，使用tsc进行编译时，不能跟上文件名，如果跟上就会忽略配置文件

# @types/node

@type 是一个ts官方的类型库，其中包含了很多对js代码的类型描述。

因为我们是要在node环境下学习所以要安装@types/node这个库

# 使用第三方库简化流程

ts-node: 将ts代码在内存中完成编译，同时完成运行

ts-node src/index.ts

nodemon: 用于监控文件的变化 

<!-- nodemon --exec ts-node src/index.ts
 -->

 nodemon --watch src -e ts --exec ts-node src/index.ts

# 基本类型约束

## 如何进行类型约束

仅需要在，变量，函数的参数，函数的返回值位置加上 ```:类型```

ts 可以进行类型推导

> 小技巧，如何区分数字字符串和数字，关键看如何读



## 源代码和编译结果的差异

编译结果中没有类型信息


# 基本类型

- number :数字
- string :字符串
- boolean :布尔
- 数组:
- object:对象
- null 和 undefined


null 和 undefined是所有类型的其它子类型

  
通过在配置文件中配置   "strictNullChecks": true 得到更加严格的类型检测


- 联合类型 : 多种类型任选其一

配合类型保护进行判断

类型保护：当对某个变量进行类型判断之后，在判断语句中便可以确定它的确切类型
typeof可以触发简单类型保护

``` let name:string|undefined = undefined ```

- viod类型：通常用于约束函数的返回值，表示该函数没有任何返回

- never类型 : 通常用于约束函数的返回值，表示该函数永远不可能结束

- 字面量类型 : 表示使用一个值进行约束 ``` let c:'A' ```

- 元祖类型（Tuple）:一个固定长度的数组，并且数组中每一项的类型确定

```let tu:[string,number]```

- any 类型 :any类型可以绕过类型检测，因此，any类型的数据是可以赋值给任何类型

# 2021/4/8
# 类型别名 ~~

对已知的一些类型定义名称

```
type 类型名字 = {

}
eg:    

type User = {
    name:string
    gender:'男'|'女'
    age:number
}

```

# 函数的相关约束 ~~
 
## 函数重载
 就是在函数实现前，对函数调用的多种情况进行声名

## 可选参数
 就是可以在某一些参数名后面加上问号，表示该参数可以不用传递，可选参数必须出现在函数的末尾

# 扩展类型-枚举 ~~

扩展类型又：类型别名 枚举  接口  类

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用，也可以达到同样的目标。

### 字面量类型的问题

- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题

- 逻辑含义和真实的值产生了混淆，会导致当修改真实值的时候，会产生大量修改

- 字面量类型不会进入到编译结果

所以这些问题需要 通过枚举来解决这些问题

### 枚举

如何定义一个枚举 

```
enum 枚举名{
    枚举字段1 = 值1,
    枚举字段2 = 值2,
}
```
枚举会表现在编译结果中，编译结果是一个对象

- 枚举的字段值可以是数字或字符串
- 数字枚举的值会自动自增
- 被数字枚举约束的变量，可以直接赋值为数字
- 数字枚举和字符串枚举编译的结果是有差异的

最佳实践：

- 尽量不要在一个枚举中即出现字符串，又出现数字字段
- 使用枚举时，尽量使用枚举字段的名称，不要使用真实的值


## 扩展知识：位枚举（枚举的位运算，争对数字枚举的）

# 模块化 ~~

tsconfig相关配置

|      配置名称      |       含义                   |
|————————————————————|—————————————————————————————|
|     module         | 设置编译结果中使用的模块化标准 |
| moduleResolution   |   设置解析模块的模式          |
| noImplicitUseStrict|  编译结果中不包含“use strict” |
|  removeComments    |   编译结果移除注释            |
|  noEmitOnError     |    错误时不生成编译结果       |
|  esModuleInterop   | 启用es模块化交互非es模块导出   |


> 前端领域中的模块化标准：ES6 commonjs amd  umd  system

##  TS如何书写模块化语句

TS，中导入和导出模块，统一使用ES6的模块化标准

#  编译结果中的模块化

# 如何在ts中使用commonjs导入导出
使用 export = {

} 这样的语法导出

用 import name  = require()  导入

# 模块解析

模块解析：应该从什么位置寻找模块

TS中，有两种模块解析策略

- classic: 经典解析  现在基本不用了
- node: node解析策略（唯一变化，是将js替换成ts）


# 接口 interface 和类型兼容性 ~~

> 扩展类型：类型别名，枚举，接口，类

typescript的接口：用于约束类，对象，函数的锲约（标准）

契约的形式:
- API文档，弱标准
- 代码约束，强标准

### 接口的的使用

1. 接口约束对象

定义一个接口
```
interface User {
    name:string,
    age:number
}
```

和类型别名一样不会出现在编译结果

2. 接口约束函数


**接口可以继承**

可以通过接口之间的继承，实现多种接口的组合

使用类型别名可以实现类似的组合效果，需要通过 & ，它叫做交叉类型

它们的区别

- 子接口不能覆盖父接口的成员

- 类型别名交叉类型，会把相同成员的类型进行交叉


**readonly**

只读修饰符 ，修饰的目标是只读的不能修改

只读修饰符，不在编译结果中
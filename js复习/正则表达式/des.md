# 正则表达式1 ~~

正则表达式是国际标准，跨语言的。

正则表达式是一个规则，用于验证字符串

## 基础

1. 字面量匹配

规则中直接书写字面量字符来进行匹配

2. 特殊字符

```js
. \\表示匹配任何字符

^ 匹配字符串的开始

$ \\表示字符串结束
```

3. 转义符
```js
\n 换行符
\t 表示制表符
\s 表示匹配空白字符
\S 除了空白字符的所有字符
\b 匹配一个单词边界，即字与空格间的位置。
\B 非单词边界和小写的相反的情况
\d 匹配0到9的数字
\D 匹配非数字
\w 匹配字母数字下划线
\W 和小写相反的
\u 根据unicode编码来匹配
```
转义符可以将特殊字符转义\\匹配\

4. 字符集
```js
 [字符范围][a-zA-Z]根据编码匹配了这个
 [0-9]=\d 匹配所有数字
 [0-9a-zA-Z] = \w
[^字符范围] ^对字符范围内取反
```
 匹配中文：\u4e00-\u9fa5  中文的编码
 ``` [\u4e00-\u9fa5] ```


 5. 量词

 ```js
* 0个或多个 \d*
+ 1个或多个 \d+
? 匹配 0个或者1个
{n}:匹配n个
{n,}:匹配大于等于n个
{n,m}:匹配n到m个

^[0-9a-zA-Z]{6,9}$ 匹配6位到9位的数子或密码开头和结尾的字符串
 ```

 6. 或者

 多个规则之间，适用 ```|``` 多个规则之间任选其一  abc|123

# 正则表达式2 ~~

## JS中的应用
js中，正则表达式表现为一个对象，该对象通过构造函数RegExp创建

### 创建方式
```js
        let reg1 = /^\d+(\.\d+)?$/flag
        let reg2 = new RegExp('^\d+(\.\d+)?$',flag);
        flag 是标志 可以有 
        
        g :表示全局搜索 

        i :忽略大小写

        m :多行匹配
```

### 正则成员

- global 这个是判断这个正则是否开启了全局匹配

- ignoreCase 是否开启了i

- multiline 是否开启了m

> 常用的2个方法

1. test方法： 验证某个字符串是否满足规则返回boolean的值
这个方法在全局模式下是不一样的，在找到匹配的项后下一次的匹配是从之前找到的位置开始的

```js
let reg = /abc/g
let str = '111abc111abc'
console.log(reg.test(str))true reg.lastIndex = 0
console.log(reg.test(str))true reg.lastIndex = 6
console.log(reg.test(str))false reg.lastIndex = 12
console.log(reg.test(str))true  reg.lastIndex = 0
```
如果不是全局匹配每一次都是从0开始匹配

> 正则表达式默认情况下采用贪婪匹配模式，尽可能的多匹配
> 我们也可以修改贪婪模式在量次后面加? 就可以 \\d+?\

2. exec方法 执行匹配 得到匹配结果返回一个数组

### 字符串对象中的正则方法
1. match方法 str.match(reg) 得到一个匹配结果一个数组
2. search方法 搜索满足条件的下标
3. split方法 str.split(reg)分割可以传入一个正则表达式
4. replace方法 表示替换字符串  str.replace(reg,',')满足正则表达式的就替换成逗
号 第2个参数可以写一个函数这个函数的第一个参数就是匹配的字符串，我们就可以根据匹配的字符串去处理然后就可以return 作为第2个参数进行替换
## 进阶

# 正则学习3之进阶 ~~

## 捕获组

用小括号包裹的部分叫捕获组，捕获组会出现在匹配结果中  就是打括号的那部分会出现在匹配的结果中
给捕获组命名?<name> 命名之后groups里面就有值了是一个对象就是
```js
let str = '2020-12-1,2019-13-3,2018-4-8'
let reg = /(?<year>\d{4})-(?<mouth>\d{1,2})-(?<day>\d{1,2})/g
while(res = reg.exec(str)){
    console.log(res); 

}
str.replace(reg,function(match,g1,g2,g3){
        // g1,g2,g3 就是捕获组的东西
})
str.replace(reg,'$1$2$3') //$1 $2 $3 就分别也是捕获组
//这样写不仅能匹配完整的年月日还能单独得到年，月，日
```
## 非捕获组 

就是写一个(?:)就是把他当成普通括号

## 反向引用

在正则表达式中，使用某一个捕获组 ```\捕获组编号``` 

```js
let reg = /(\d{2}\1)/
var s = '1313'
reg.test(s)//true 
//就是说\1哪里是会用第一个捕获组的结果放在那去匹配的 如果s是1314那就是不匹配的
```
下面的题就是巧妙的利用反向引用
```js
let s = 'aaaaabbbbjdfcccc'
//找出该字符串中连续的字符 
let reg = /(\w)\1+/g
 while(res = reg.exec(str)){
    console.log(res[1]); 
}
```

## 正向断言（预查）(?=) 

检查某个字符串后面的字符是否满足某一个规则，
该规则不进入捕获组，该规则不成为匹配结果
**(?=)**

```js
let s  = 'asdasdasda123asdas12asc123c123'
//找到后面是数字的字母
let reg = /[a-zA-Z](?=\d+)/g
 while(res = reg.exec(s)){
    console.log(res); 
}
```
一道题
```js
let s = '12323441';
// 规则从右向左每三位加上一个逗号
//  得到结果var  res = '12,323,441' 
var reg = /\B(?=(\d{3})+$)/g 
//就是匹配一个空字符 空字符后面出现3的倍数次的结果
//然后替换掉这个空字符位，
s=s.replace(reg,',')
console.log(s);
```

## 负向断言（?!）

检查某个字符串后面的字符是否不满足某一个规则，

该规则不进入捕获组，该规则不成为匹配结果

**判断密码强度**

要求密码中必须出现小写大写字母数字特殊字符(!@#_.)
```js
var s = '24Add34D.'
var reg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[\d])(?=.*[!@#_,.]).{6,12}$/
console.log(reg.test(s))
```

# 错误处理 ~~